/*  *********************************************
     Mandrino on ESP32, send raw datas to an MQTT
     Broker

     Utilizing Sparkfun's ADXL345 Library
     supporting SPI Communication

     DB GDC
     Development Environment Specifics:
     Arduino 1.8.13

     Hardware Specifications:
     ADXL345
     ESP32

     gains to convert samples to humans:
     gains[0] = 0.00376390;
     gains[1] = 0.00376009;
     gains[2] = 0.00349265;

 *  *********************************************/
#include "header.h"

/*          Configure ADXL345 Settings         */
void config_Sensor(ADXL345 * cfg, int fullscale) {

  cfg->powerOn();                     // Power on the ADXL345

  cfg->setRangeSetting(fullscale);           // Give the range settings
  // Accepted values are 2g, 4g, 8g or 16g
  // Higher Values = Wider Measurement Range
  // Lower Values = Greater Sensitivity
  cfg->setFullResBit(false);
  cfg->setSpiBit(0);                  // Configure the device to be in 4 wire SPI mode when set to '0' or 3 wire SPI mode when set to 1

  cfg->setRate(ADXL345_RATE_3200);

  cfg->setInterrupt(7, 1);

}


bool mqtt_reconnect(int Retry_MQTT) {
  // Loop until we're reconnected
  int retry = 0;
  while (!client.connected() && (retry < Retry_MQTT)) {
#if VERBOSE == 1
    Serial.print("Attempting MQTT connection...");
#endif
    // Create a random client ID
    String clientId = "ESP32Client-";
    clientId += String(random(0xffff), HEX);
    // Attempt to connect
    if (client.connect(clientId.c_str(), wifi_settings.mqttuser, wifi_settings.mqttpwd)) {
#if VERBOSE == 1
      Serial.println("connected");
#endif
    } else {
#if VERBOSE == 1
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
#endif
      // Wait 5 seconds before retrying
      retry++;
      delay(5000);
    }
  }
  if (retry >= Retry_MQTT )
    return false;
  else
    return true;
}

void handleInterrupt() {

  portENTER_CRITICAL_ISR(&timerMux);
  isrCounter++;
  portEXIT_CRITICAL_ISR(&timerMux);

  xSemaphoreGiveFromISR(timerSemaphore, NULL);

}

void setup() {

  Serial.begin(500000);
  Serial.println("ESP32 Drill application: initialiting!");
  Serial.println();
  pinMode(clearFlashBtn, INPUT);
  pinMode(interruptPin, INPUT);
  
  pinMode(Led1 , OUTPUT);
  pinMode(Led2 , OUTPUT);

  digitalWrite(Led1, LOW);
  digitalWrite(Led2, HIGH);
  
  attachInterrupt(digitalPinToInterrupt(interruptPin), handleInterrupt, RISING);
  
  Serial.println("Press button in 5 seconds to erase flash memory.");
  int counter = millis();
  while ( millis() - counter < 5000) {
    if (digitalRead(clearFlashBtn) == HIGH)
    {
#if VERBOSE == 1
      Serial.println("Erasing memory");
#endif
      digitalWrite(Led1, HIGH);
      digitalWrite(Led2, LOW);

      delay(1000);
      
      digitalWrite(Led1, LOW);
      digitalWrite(Led2, HIGH);

      delay(1000);
      
      Wifi_custom.clear_credential();
      ESP.restart();
    }
  }

    // Initialize SPIFFS
  if(!SPIFFS.begin(true)){
    Serial.println("An Error has occurred while mounting SPIFFS");
    return;
  }


  if(Wifi_custom.check_credential(&wifi_settings) == false){
  /***********************WIFI SOFT AP FOR CONF*********************/
  char wifiname[40];
  sprintf (wifiname  , "%ll012X" , ESP.getEfuseMac() );
  Wifi_custom.set_wifi_ap(wifiname, "12345678");
 
  server.on("/", HTTP_GET, [](){
    if(!handleFileRead("/config.html")) server.send(404, "text/plain", "FileNotFound");
  });
  server.on("/Configuration", handle_OnReceiveParam);
  server.on("/MacAddr", handle_OnMacBtn);
  server.begin();
  while(1)  server.handleClient();
  /****************************************************************/
  }else{
    digitalWrite(Led1, HIGH);
    digitalWrite(Led2, LOW);
  /****************WIFI INIT CONNECTION TO NETWORK****************/
    //Wifi_custom.sleep_wifi();
    delay(1000);   
    //Wifi_custom.print_info_wifi(wifi_settings.ssid,wifi_settings.ssidpwd,wifi_settings.mqttaddr,wifi_settings.mqttport, wifi_settings.mqttuser ,wifi_settings.mqttpwd, wifi_settings.ntpserver ) ;
    if( strlen(wifi_settings.ip) != 0 && strlen(wifi_settings.subnet) !=0 && strlen(wifi_settings.gw) !=0 ){
      Wifi_custom.conf_static_settings(wifi_settings.ip,wifi_settings.gw,wifi_settings.subnet);
    }
    if( strlen(wifi_settings.ntpserver) == 0) {
     sprintf(wifi_settings.ntpserver,"it.pool.ntp.org");
    }
    Wifi_custom.retrieve_NTP(wifi_settings.ssid, wifi_settings.ssidpwd, WIFI_ATTEMPT , &unixTime, wifi_settings.ntpserver);
      
    //connection_state = Wifi_custom.setup_wifi(wifi_settings.ssid,wifi_settings.ssidpwd,WIFI_ATTEMPT);
   
    connection_state = false;

   // digitalWrite(Led1, LOW);
   // digitalWrite(Led2, HIGH);
    
    int port = atoi(wifi_settings.mqttport);

    sprintf (nametopicaccxyz  , MQTT_TOPIC_DRILL_DATA , ESP.getEfuseMac() );
    client.setServer(wifi_settings.mqttaddr, port);
    
    startmillis = millis();
    
    if (connection_state == true ) {
    Serial.println("Fail!");
    } else {
    Serial.print("Connect to: ");
    Serial.println(wifi_settings.ssid);
    }
    
  }
  int fscale = atoi(wifi_settings.fullscale);
  config_Sensor(&adxl, fscale );
  
  timerSemaphore = xSemaphoreCreateBinary();

  adxl.readAccel(&x, &y, &z);

}

void loop() {

  if (xSemaphoreTake(timerSemaphore, 0) == pdTRUE) {
    uint32_t isrCount = 0;
    portENTER_CRITICAL(&timerMux);
    isrCount = isrCounter;
    portEXIT_CRITICAL(&timerMux);

    dt = (micros() - dtlv);
    dtlv = micros();
    adxl.readAccel(&x, &y, &z);
    if (sampleCounter == 0) {
      miss = millis();
    }

    bcountXYZ[packetCounter].datas[sampleCounter++]   =   (x & 0xFF00) >> 8;
    bcountXYZ[packetCounter].datas[sampleCounter++]   =   x & 0xFF ;
    bcountXYZ[packetCounter].datas[sampleCounter++]   =   (y & 0xFF00) >> 8;
    bcountXYZ[packetCounter].datas[sampleCounter++]   =   y & 0xFF;
    bcountXYZ[packetCounter].datas[sampleCounter++]   =   (z & 0xFF00) >> 8;
    bcountXYZ[packetCounter].datas[sampleCounter++]   =   z & 0xFF;
    if (sampleCounter >= MEAS_PER_TRANSMISSION * 2) {

      sampleCounter = 0;

      for (int j = 0; j < LEN_HEADER; j++) {

        bcountXYZ[packetCounter].unix[j]    = ((unixTime + elapsed / 1000) &  (0xFF000000 >> (j * 8))) >> ((LEN_HEADER - 1 - j) * 8);
        bcountXYZ[packetCounter].ms[j]      = (miss &  (0xFF000000 >> (j * 8))) >> ((LEN_HEADER - 1 - j) * 8);
        bcountXYZ[packetCounter].fc[j]      = (((int) dt) &  (0xFF000000 >> (j * 8))) >> ((LEN_HEADER - 1 - j) * 8);        
        bcountXYZ[packetCounter].num_pkt[j] = (((int) number_trans) &  (0xFF000000 >> (j * 8))) >> ((LEN_HEADER - 1 - j) * 8);
      }

      packetCounter++;
      number_trans++;
    }

#if SERIAL_PRINT == 1
    Serial.print(x);
    Serial.print(", ");
    Serial.print(y);
    Serial.print(", ");
    Serial.println(z);
#endif

    if (packetCounter >= N_PACKET) {
      if (connection_state == false) {
        if (!client.connected()) {
          status_mqtt = mqtt_reconnect(MQTT_ATTEMPT);
        }
        if (status_mqtt)
        {
          digitalWrite(Led1, LOW);
          client.loop();

          int i, j, numChar = 0;
          char timePublish[15];
          byte * p;
          p = (byte *) bcountXYZ;

          nowmillis = millis() - startmillis;
          elapsed += nowmillis;

          for (i = 0 ; i < (N_PACKET) * (LEN_PACKET) ; i += LEN_PACKET) {
              startmillis = millis();
              client.publish(nametopicaccxyz, p + i , LEN_PACKET );
          }
          sampleCounter = 0;
          packetCounter = 0;

        }else {
          Serial.println("The MQTT is KO");
          Wifi_custom.sleep_wifi();
          Wifi_custom.setup_wifi(wifi_settings.ssid,wifi_settings.ssidpwd,WIFI_ATTEMPT);
          //connection_state = Wifi_custom.setup_wifi(ssid, password, WIFI_ATTEMPT);
          sampleCounter = 0;
          packetCounter = 0;
          digitalWrite(Led1, HIGH);
        }
      } else {
#if VERBOSE == 1
        Serial.println("Failed to connect to wifi. Rebooting in 5 secs.");
#endif
        sampleCounter = 0;
        packetCounter = 0;
        digitalWrite(Led1, HIGH);
        delay(5000);
        ESP.restart();
      }

    }
  }

}
void handle_OnMacBtn(){
  
  String stringChipId = Wifi_custom.get_MACid();
  char name_b[40];
  sprintf (name_b  , " uuid : %ll012X" , ESP.getEfuseMac() );
  
  server.send(200, "text/html","mac: " + stringChipId + String(name_b));
}


void handle_OnReceiveParam(){

#if DEBUG == 1
  //Serial.println(server.arg("bname"));
  Serial.println(server.arg("ssid"));
  Serial.println(server.arg("ssidpwd"));
  Serial.println(server.arg("mqttaddr"));
  Serial.println(server.arg("mqttport"));
  Serial.println(server.arg("mqttuser"));
  Serial.println(server.arg("mqttpwd"));
  Serial.println(server.arg("ntpserver"));
  //Serial.println(server.arg("dhcp"));
  Serial.println(server.arg("ip"));
  Serial.println(server.arg("subnet"));
  Serial.println(server.arg("gw")); 
  Serial.println(server.arg("accel")); 
#endif
  
  //server.arg("bname").toCharArray(wifi_settings.bname,server.arg("bname").length()+1  );  
  server.arg("ssid").toCharArray(wifi_settings.ssid,server.arg("ssid").length()+1    );   
  server.arg("ssidpwd").toCharArray(wifi_settings.ssidpwd,server.arg("ssidpwd").length() +1   );
  server.arg("mqttaddr").toCharArray(wifi_settings.mqttaddr,server.arg("mqttaddr").length()+1  ); 
  server.arg("mqttport").toCharArray(wifi_settings.mqttport,server.arg("mqttport").length()+1  );  
  server.arg("mqttuser").toCharArray(wifi_settings.mqttuser,server.arg("mqttuser").length()+1  );    
  server.arg("mqttpwd").toCharArray(wifi_settings.mqttpwd,server.arg("mqttpwd").length() +1   );  
  server.arg("ntpserver").toCharArray(wifi_settings.ntpserver,server.arg("ntpserver").length() +1   );  
  server.arg("ip").toCharArray(wifi_settings.ip,server.arg("ip").length()+1       );
  server.arg("subnet").toCharArray(wifi_settings.subnet,server.arg("subnet").length()+1     );
  server.arg("gw").toCharArray(wifi_settings.gw,server.arg("gw").length()+1       );
  server.arg("accel").toCharArray(wifi_settings.fullscale,server.arg("accel").length()+1       );
  
  Wifi_custom.initialize_credential_fromWebpage(&wifi_settings);
  server.send(200, "text/html");
  //delay(2000);
  //ESP.restart();
  
}
void handle_Conf() {
  
    String myFile = "/config.html";
    
    if (SPIFFS.exists(myFile)) {
      Serial.println(F("myFile founded on   SPIFFS"));
      
      File file = SPIFFS.open(myFile, "r");    
      
      size_t sent = server.streamFile(file, "text/css");
      file.close();
    }
}
String getContentType(String filename){
  if(server.hasArg("download")) return "application/octet-stream";
  else if(filename.endsWith(".htm")) return "text/html";
  else if(filename.endsWith(".html")) return "text/html";
  else if(filename.endsWith(".css")) return "text/css";
  else if(filename.endsWith(".js")) return "application/javascript";
  else if(filename.endsWith(".png")) return "image/png";
  else if(filename.endsWith(".gif")) return "image/gif";
  else if(filename.endsWith(".jpg")) return "image/jpeg";
  else if(filename.endsWith(".ico")) return "image/x-icon";
  else if(filename.endsWith(".xml")) return "text/xml";
  else if(filename.endsWith(".pdf")) return "application/x-pdf";
  else if(filename.endsWith(".zip")) return "application/x-zip";
  else if(filename.endsWith(".gz")) return "application/x-gzip";
  return "text/plain";
}
bool handleFileRead(String path){
  Serial.println("handleFileRead: " + path);
  if(path.endsWith("/")) path += "index.htm";
  String contentType = getContentType(path);
  String pathWithGz = path + ".gz";
  if(SPIFFS.exists(pathWithGz) || SPIFFS.exists(path)){
    if(SPIFFS.exists(pathWithGz))
      path += ".gz";
    File file = SPIFFS.open(path, "r");
    size_t sent = server.streamFile(file, contentType);
    file.close();
    return true;
  }
  return false;
}
